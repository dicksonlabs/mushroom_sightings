require 'active_record_extensions'

################################################################################
#
#  Model describing a species list.  A species list is a list of Observation's
#  (*not* Name's).  Basic properties: 
#
#  1. has a date, title, and notes
#  2. has a "where" (*not* a Location)
#  3. is owned by a User
#  4. has zero or more Observation's
#  5. has an RssLog
#
#  Public Methods:
#    log(msg)              Add message to RssLog
#    orphan_log(entry)     Tell RssLog we're about to be deleted.
#
#    unique_text_name      Return title with id appended to make it unique.
#    unique_format_name    (same thing, to be consistent with name, image, etc.)
#
#    construct_observation(name, args)  Create and add Observation to list.
#    update_names(chosen_names)         Update Names in list based on "chosen_names" radio boxes.
#    name_included(name)                Does this list include the given Name?
#    names                              Get sorted list of name objects.
#
#    file=(file_field)             Upload text file into internal "data" field.
#    process_file_data(sorter)     Process uploaded file.  Pass in NameSorter object.
#
#  Callbacks:
#    after_add         Update user contribution when adding/removing observations.
#    before_remove
#
#  Validates:
#    must have title and "where"
#
################################################################################

class SpeciesList < ActiveRecord::Base
  has_and_belongs_to_many :observations,
    :after_add => :add_obs_callback, :before_remove => :remove_obs_callback
  belongs_to :user
  has_one :rss_log
  attr_accessor :data

  def add_obs_callback(o) # :nodoc:
    SiteData.update_contribution(:create, self, :species_list_entries, 1)
  end

  def remove_obs_callback(o) # :nodoc:
    SiteData.update_contribution(:destroy, self, :species_list_entries, 1)
  end

  # Add message to RssLog.
  def log(*args)
    self.rss_log ||= RssLog.new
    self.rss_log.add_with_date(*args)
  end

  # Inform RssLog we're about to be deleted.
  def orphan_log(*args)
    self.rss_log ||= RssLog.new
    self.rss_log.orphan(self.unique_format_name, *args)
  end

  # Get list of Name objects, sorted by text_name.
  def names
    # Takes 0.11 seconds on Sebastopol Observations.
    ids = self.observations.map {|o| o.name_id}.uniq
    Name.find(:all, :conditions => ['id IN (?)', ids], :order => 'text_name ASC')
    
    # Takes 0.41 seconds on Sebastopol Observations.
    # self.observations.map {|o| o.name_id}.
    #   uniq.map {|id| Name.find(id)}.sort_by {|n| n.text_name}
  end

  # Returns empty string.  Used by a form?
  def species
    ''
  end

  # Does absolutely nothing.  Used by a form?
  def species=(list)
  end

  # Upload file into internal "data" attribute.
  def file=(file_field)
    if file_field.kind_of?(StringIO)
      content_type = file_field.content_type.chomp
      if ('application/text' == content_type or 'text/plain' == content_type or 'application/octet-stream' == content_type)
        self.data = file_field.read
      else
        raise sprintf("Unrecognized content_type: %s\n", content_type)
      end
    else
      raise sprintf("Unrecognized file_field class: %s\n", file_field.class)
    end
  end

  # Process simple species lists of the form [<name>{\n\r}]+
  def process_simple_list(sorter)
    entry_text = self.data.split(/\s*[\n\r]\s*/)
    entry_text.each do |e|
      sorter.add_name(e.strip.squeeze(' '))
    end
  end

  # Process species lists that get generated by the Name species listing program
  def process_name_list(sorter)
    entry_text = self.data.gsub('[','').split(/\s*\r\]\r\s*/)
    entry_text.each do |e|
      timestamp = nil
      what = nil
      e.split(/\s*\r\s*/).each do |key_value|
        kv = key_value.split(/\s*\|\s*/)
        if kv.length != 2
          raise sprintf("Bad key|value pair (%s) in %s", key_value, filename)
        end
        key, value = kv
        if key == 'Date'
          timestamp = Time.local(*(ParseDate.parsedate(value)))
        elsif key == 'Name'
          what = value.strip.squeeze(' ')
        elsif key == 'Time'
          # Ignore
        else
          raise sprintf("Unrecognized key|value pair: %s\n", key_value)
        end
      end
      if what
        sorter.add_name(what, timestamp)
      end
    end
  end

  # Process uploaded file.
  def process_file_data(sorter)
    if self.data
      if self.data[0] == 91 # '[' character
        process_name_list(sorter)
      else
        process_simple_list(sorter)
      end
    end
  end

  # Return title with id appended to make in unique.
  def unique_text_name
    title = self.title
    if title
      sprintf("%s (%d)", title, self.id)
    else
      sprintf("Species List %d", self.id)
    end
  end
  alias :unique_format_name :unique_text_name

  # Create and add a minimal Observation (with associated Naming and optional
  # Vote objects), and add it to the SpeciesList.
  def construct_observation(name, args)
    if name != ''
      obs = Observation.new({
        :created  => args[:created],
        :modified => args[:modified],
        :when     => args[:when],
        :user     => args[:user],
        :where    => (args[:where] == '' ? self.where : args[:where]),
        :specimen => args[:specimen],
        :notes    => args[:notes],
        :name     => name
      })
      obs.save
      naming = Naming.new({
        :created     => args[:created],
        :modified    => args[:modified],
        :observation => obs,
        :name        => name,
        :user        => args[:user]
      })
      naming.save
      if !args[:vote].nil?
        vote = Vote.new({
          :created     => args[:created],
          :modified    => args[:modified],
          :user        => args[:user],
          :naming      => naming,
          :observation => obs,
          :value       => args[:vote]
        })
        vote.save
      end
      self.observations << obs
    end
  end

  # Changes names of certain Observation's based on the "chosen_names" hash
  # (which originates as params[:chosen_approved_names] radio boxes).
  def update_names(chosen_names)
    if chosen_names
      for observation in self.observations
        for naming in observation.namings
          alt_name_id = chosen_names[naming.name.search_name.gsub(/\W/, "_")] # Compensate for gsub in _form_species_lists
          if alt_name_id
            alt_name = Name.find(alt_name_id)
            if alt_name
              naming.name = alt_name
              naming.save
            end
          end
        end
      end
    end
  end

  # Tests to see if the species list includes an observation with the given
  # name (checks consensus only).  Primarily used by functional tests.
  def name_included(name)
    for observation in self.observations
      return true if observation.name == name
    end
    return false
  end

  protected

  def validate # :nodoc:
    if self.title.to_s.blank?
      errors.add(:title, :validate_species_list_title_missing.t)
    elsif self.title.length > 100
      errors.add(:title, :validate_species_list_title_too_long.t)
    end

    if self.where.to_s.blank?
      errors.add(:where, :validate_species_list_where_missing.t)
    elsif self.where.length > 100
      errors.add(:where, :validate_species_list_where_too_long.t)
    end

    if !self.user
      errors.add(:user, :validate_species_list_user_missing.t)
    end
  end
end
