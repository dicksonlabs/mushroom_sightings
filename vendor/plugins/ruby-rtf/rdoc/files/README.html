<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Dec 31 16:00:00 -0800 1969</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h2>Ruby Rich Text Format (<a href="../classes/RTF.html">RTF</a>) Library 0.1.0</h2>
<p>
The <a href="../classes/RTF.html">RTF</a> library provides a pure Ruby set
of functionality that can be used to programmatically create <a
href="../classes/RTF.html">RTF</a> documents. The main aim in developing
this library is to ease the complexity involved in assembling <a
href="../classes/RTF.html">RTF</a> documents although some consideration
has also been given to generating documents that are easier to manually
interpret too.
</p>
<p>
This library does not include functionality for parsing <a
href="../classes/RTF.html">RTF</a> documents. Nor does the library claim to
provide extensive coverage of the <a href="../classes/RTF.html">RTF</a>
specification. The library was developed mostly with reference to the <a
href="../classes/RTF.html">RTF</a> Pocket Guide by Sean M. Burke and some
reference to the <a href="../classes/RTF.html">RTF</a> specification
itself. The introduction to the <a href="../classes/RTF.html">RTF</a>
Pocket Guide states that the book covers version 1.7 of the <a
href="../classes/RTF.html">RTF</a> specification so I guess, as this was
the primary source, that this is the version that the library covers too.
Finally, no consideration was given to making the functionality within the
library thread safe.
</p>
<p>
In creating this library I set out to make it reasonably easy to create <a
href="../classes/RTF.html">RTF</a> documents in code. Having said that
I&#8216;m certain that it is possible to generate invalid <a
href="../classes/RTF.html">RTF</a> documents with this library.
</p>
<h3>Known Issues</h3>
<p>
I&#8216;ve tried to assemble a reasonably extensive (although I won&#8216;t
claim exhaustive) unit test for the library. Despite that, this is an early
release of the code and I&#8216;m sure there will be issues with it given
the complexity inherent in <a href="../classes/RTF.html">RTF</a>. The
following are issues that I&#8216;m already aware of with the
library&#8230;
</p>
<ul>
<li>The implementation of headers and footers is incomplete. Stick to using
universal headers and footers for the time being.

</li>
<li>The library makes no attempt to split large chunks of text into separate
lines. This can make editing the resulting document in a text editor a
little awkward.

</li>
<li><a href="../classes/RTF.html">RTF</a> is, when it comes down to it, a
Microsoft standard. As a result I have taken Word and Wordpad to be
definitive when it comes to displaying the <a
href="../classes/RTF.html">RTF</a> documents generated by the library. I
have tried things like Abiword and Open Office with varying degrees of
success. I&#8216;m certainly not saying that this is due to deficencies in
these particular applications as it could equally be a lack of my
understanding of the <a href="../classes/RTF.html">RTF</a> standard or
problems with my implementation. Still, I think I should mention the point
that I don&#8216;t get consistent appearance across all of the <a
href="../classes/RTF.html">RTF</a> viewers I&#8216;ve tried.

</li>
</ul>
<h3>To Do</h3>
<p>
This section details that areas where I feel the library is currently
lacking or incomplete. I hope to address the things detailed here in later
releases of the code.
</p>
<ul>
<li>Check into <a href="../classes/RTF.html">RTF</a> image handling with a view
to adding support for the insertion of images into a Document.

</li>
<li>Provide a complete implementation for the headers and footers.

</li>
</ul>
<h3>Some Examples</h3>
<p>
Okay, so how is the library used. Well lets look at some examples to see if
we can cast a little light on the matter. The examples provided here assume
that you are already familiar with the Ruby language. So, for a start,
consider&#8230;
</p>
<pre>
   require 'rubygems'
   require 'rtf'

   include RTF
</pre>
<p>
The first thing to look at here at the are the first two lines. The <a
href="../classes/RTF.html">RTF</a> library is provided as a Ruby gem and
these two lines load the libraries functionality into the script. The third
line of code includes the <a href="../classes/RTF.html">RTF</a> module into
the current name space. This is a convenience mechanism that saves on
specifically having to refer to the module when accessing the <a
href="../classes/RTF.html">RTF</a> library. Next we want to create an <a
href="../classes/RTF.html">RTF</a> document and that is done like
this&#8230;
</p>
<pre>
   document = Document.new(Font.new(Font::ROMAN, 'Times New Roman'))
</pre>
<p>
This line of code creates a new Document object, specifying that the
default font for the document will the the Times New Roman font. So we have
a document, what can we do with it. Well, lets add a short paragraph of
text&#8230;
</p>
<pre>
   document.paragraph &lt;&lt; &quot;This is a short paragraph of text.&quot;
</pre>
<p>
That&#8216;s fine, but what if we wanted to extend that paragraph or we
simply wanted to add more text than we&#8216;ve added here? Well, the
paragraph method accepts a block to which it passes the actual paragraph
object, so we could do something like the following&#8230;
</p>
<pre>
   document.paragraph do |p|
      p &lt;&lt; &quot;This is the first sentence in the paragraph. &quot;
      p &lt;&lt; &quot;This is the second sentence in the paragraph. &quot;
      p &lt;&lt; &quot;And this is the third sentence in the paragraph.&quot;
   end
</pre>
<p>
This is a common approach used by the <a href="../classes/RTF.html">RTF</a>
library, allowing a block to define the scope of a document element. Lets
see a more complicated example of this in which we apply a number of
document effects. Lets say that we want to insert some code into the
document. We want the code to appear in the document slightly indented on
the left hand side, in a non-proportionately space font and we want it in
bold text. Heres the code that shows how to do that&#8230;
</p>
<pre>
   01 styles = {}
   02 styles['PS_CODE'] = ParagraphStyle.new
   03 styles['CS_CODE'] = CharacterStyle.new
   04
   05 styles['PS_CODE'].left_indent = 200
   06 styles['CS_CODE'].font        = Font.new(Font::MODERN, 'Courier')
   07 styles['CS_CODE'].bold        = true
   08
   09 document.paragraph(styles['PS_CODE']) do |n1|
   10    n1.apply(styles['CS_CODE']) do |n2|
   11       n2 &lt;&lt; &quot;count = 0&quot;
   12       n2.line_break
   13       n2 &lt;&lt; &quot;File.open('file.txt', 'r') do |file|&quot;
   14       n2.line_break
   15       n2 &lt;&lt; &quot;   file.each_line {|line| count += 1}&quot;
   16       n2.line_break
   17       n2 &lt;&lt; &quot;end&quot;
   18       n2.line_break
   19       n2 &lt;&lt; &quot;puts \&quot;File contains \#{count} lines.\&quot;&quot;
   20    end
   21 end
</pre>
<p>
This is a much larger piece of code and covers a number of topics that need
to be addressed. I have included line numbers with code so that individual
elements can be referenced. Lines 1 to 3 are the first new elements. Here
we create a Hash and assign it to a variable called styles. On the next two
lines we create two style objects, one that can be applied to paragraphs
and one that applies to characters.
</p>
<p>
On lines 5 to 7 we update settings on the style objects we&#8216;ve
created. We set the left indentation value of the paragraph style to 200.
The 200 in this case refers to a measurement of twips. A twip is a type
setting measurement that equates to one twentieth of a point (about a fifty
seventh of a millimetre or one seventy second of an inch). This is the
measurement scale used by <a href="../classes/RTF.html">RTF</a> documents
so it is also employed in the library.
</p>
<p>
On lines 6 and 7 we update the character style to use a courier font and to
apply bold styling to the text. On line 9 we start a new paragraph in our
document. This differs from our previous use of this method in that we
specify a style that will be applied to the paragraph created, the
paragraph style we had prepared earlier.
</p>
<p>
The block accompanying the paragraph method takes the single parameter that
we have seen previously. At this point its probably a good idea to point
out that the elements that make up an <a href="../classes/RTF.html">RTF</a>
document created with the library are all stored as nodes in a tree.
We&#8216;ve named the one passed to the paragraph method as n1 to reflect
this.
</p>
<p>
Within the block we&#8216;ve called a method on the paragraph node called
apply. This method applies a character style and we&#8216;re using the one
we prepared earlier. Like the call to the paragraph method, the apply
method is passed a block. All text added to the blocks node (n2 in this
case) will have the styling we&#8216;ve defined (bold courier font) applied
to it.
</p>
<p>
Note, that within the apply block we could still use the n1 node. Any text
we added to this would appear in the paragraph but wouldn&#8216;t be styled
and, it should be noted, will appear before any text added to n2 (as the n2
node only becomes part of the document when the apply block completes).
</p>
<p>
Within the apply method block we add some lines of text to the n2 node.
Note that, as this is all encompassed within the parapgraph block, all the
text is part of a single paragraph. To get each of the lines of code to
appear on a line of their own we have used the line_break method which
inserts a carriage return into the document. Note you should use this
method to insert line breaks rather than trying to add a string containing
&quot;\n&quot;. <a href="../classes/RTF.html">RTF</a> is a text based
standard and won&#8216;t treat &quot;\n&quot; as you&#8216;re expecting.
You should note also that we&#8216;ve had to escape the &#8217;#&#8217; in
one of the code lines to stop Ruby considering it as an interpolated value.
</p>
<p>
Okay, so we&#8216;ve seen have the basics of creating a document and adding
elements to that document. How do we get what we&#8216;ve created to a
file. Well thats actually quite straight forward. As was mentioned
previously, <a href="../classes/RTF.html">RTF</a> is a text based standard
so you simply generate the <a href="../classes/RTF.html">RTF</a> and write
it to a file. Heres an example&#8230;
</p>
<pre>
   File.open('my_document.rtf') {|file| file.write(document.to_rtf)}
</pre>
<p>
There you have it. You&#8216;ve been given a quick overview of the basics
of using the library. For more information consult the HTML based API
documentation that is installed with the library gem (if you&#8216;re
reading this you may already be looking at this documentation). Another
source of information is the examples directory, so check that out too.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>